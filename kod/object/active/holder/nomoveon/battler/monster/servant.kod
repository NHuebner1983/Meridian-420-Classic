// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
Servant is Monster

constants:

   include blakston.khd
   
   // Distance from master before we abandon the fight
   RETREAT_DISTANCE = 100
   
   // Distance from master if we're just sitting there
   IDLE_DISTANCE    = 20

resources:

   servant_koc_name_rsc = "servantfairyshouldnotkocname"
   servant_name_rsc = "servant"
   servant_icon_rsc = faerie-g.bgf
   servant_desc_rsc = \
      "A magical creature."

   servant_empty_rsc = ""
   
   servant_dead_icon_rsc = faerieXG.bgf
   servant_dead_name_rsc = "dead servant"

   servant_fireball = feyball.bgf
   servant_sound_hit = none
   servant_sound_miss = none
   servant_sound_death = none
   servant_sound_aware = none
   
   // Servant commands
   servant_command_quiet = "shut up"
   servant_command_loud = "talk more"
   servant_command_help = "help"
   servant_command_no_buffs = "stop buffing me"
   servant_command_do_buffs = "buff me"
   servant_command_taunt = "taunt"
   servant_command_attack = "attack"
   servant_command_stop_taunting = "stop taunting"
   servant_command_stop_attacking = "stop attacking"
   servant_command_heal_me = "heal me"
   servant_command_feed_me = "feed me"
   servant_command_mystify_me = "mystify me"
   servant_command_go_away = "go away"
   
   // Servant help response
   servant_response_help = \
      "~kYour servant replies in a sarcastic tone...''Well, if it isn't the almighty master asking for my help...''~k\n"
      "~kYour servant whispers to you, ''Don't worry, I've got you covered. Also, check my description to see my powers.''~k\n"
      "~b~BYour servant clears their throat to begin a long speech...~B~b\n"
      "~r~B''say shut up'' ~r~B~kand I will certainly stop talking. So rude of you.~k\n"
      "~r~B''say talk more'' ~r~B~kand I will be encouraged to talk more. I have lots to say about myself.~k\n"
      "~r~B''say stop buffing me'' ~r~B~kand I will stop casting beneficial spells...your loss pal.~k\n"
      "~r~B''say buff me'' ~r~B~kand I will resume casting beneficial spells.~k\n"
      "~r~B''say stop taunting'' ~r~B~kand I will stop trying to steal your aggro.~k\n"
      "~r~B''say taunt'' ~r~B~kand it will send me into a rage, stealing your aggro, but it will hurt me a lot.~k\n"
      "~r~B''say stop attacking'' ~r~B~kand I will let you do all of the hard work.~k\n"
      "~r~B''say attack'' ~r~B~kand I will attack your enemies.~k\n"
      "~r~B''say heal me'' ~r~B~kand I will try to use a heal wand I stoled from that corpse over there.~k\n"
      "~r~B''say feed me'' ~r~B~kand I will try to feed you some food I ''may'' have stolen from you. You can't prove anything.~k\n"
      "~r~B''say mystify me'' ~r~B~kand I will give you some of the mana I have been stealing from you.~k\n"
      "~r~B''say go away'' ~r~B~kand I will leave you to fend for yourself. I have better things to do anyways, loser.~k\n"
   
   // RPG Random Names
   servant_name_1 = "Eimmilth, The Mammoth"
   servant_name_2 = "Purve, Champion Of The Black"
   servant_name_3 = "Lathynth, The Fast One"
   servant_name_4 = "Oadat, Lady Of Ice"
   servant_name_5 = "Purse, The Quiet"
   servant_name_6 = "Cuvy, Lady Of The Red"
   servant_name_7 = "Cirros, Eater Of Sheep"
   servant_name_8 = "Inarryl, The Young One"
   servant_name_9 = "Legiry, Lady Of The Brown"
   servant_name_10 = "Nekonys, The Swift"
   servant_name_11 = "Mammoth, Protector Of The Sky"
   servant_name_12 = "Aekorth, Champion Of The Green"
   servant_name_13 = "Osseorth, Lady Of The Red"
   servant_name_14 = "Conu, The Puny"
   servant_name_15 = "Zirlorth, Longtail"
   servant_name_16 = "Doni, The Swift"
   servant_name_17 = "Qaghar, The Loud"
   servant_name_18 = "Govnontys, The Black"
   servant_name_19 = "Eldridelth, Redeemer Of Men"
   servant_name_20 = "Termarro, The Black"
   servant_name_21 = "Chaynnuth, The Scary One"
   servant_name_22 = "Tommei, The Powerful"
   servant_name_23 = "Xaeloar, Protector Of The Sky"
   servant_name_24 = "Taileon, Lord Of Ice"
   servant_name_25 = "Zaeghuth, The Barbarian"
   servant_name_26 = "Niepad, The Mysterious One"
   servant_name_27 = "Daithunth, The Eternal One"
   servant_name_28 = "Xiodreiphae, The Firestarter"
   servant_name_29 = "Deindurut, The Mysterious One"
   servant_name_30 = "Iadhuphil, Lord Of Ice"
   servant_name_31 = "Chesorth, Eater Of Bunnies"
   servant_name_32 = "Qavy, The Strong"
   servant_name_33 = "Oka, Icebreath"
   servant_name_34 = "Yvno, The Gentle"
   servant_name_35 = "Idil, The Champion"
   servant_name_36 = "Qirmit, Protector Of Life"
   servant_name_37 = "Imre, The White One"
   servant_name_38 = "Chuneintarth, Protector Of The Forest"
   servant_name_39 = "Orgyrrut, The Insane"
   servant_name_40 = "Eivnirarth, The Evil One"

   // Chatter   
   servant_rant_a = "This room could use a little more sunlight."
   servant_rant_b = "That was a close one."
   servant_rant_c = "Pking is pretty fun if I say so myself."
   servant_rant_d = "Should we break for tea?"
   servant_rant_e = "I'm anxious to kill stuff!"
   servant_rant_f = "Do you know what is hidden behind the flag in the streets of tos?"
   servant_rant_g = "Berserker rings are overrated."
   servant_rant_h = "Orcs are my least favorite creature - too many teef."
   servant_rant_i = "Giant rats would make good pets and torture devices."
   servant_rant_j = "Cyrus the Virus knows a little too much about PKing."
   servant_rant_k = "This glowing magic aura is way too bright, how can you even see?"
   servant_rant_l = "You know Dev right, he makes interesting things."
   servant_rant_m = "I once caught Diggie with his pants down in the lover's tryst."
   servant_rant_n = "Did you know that 95 percent of marriages in meridian were under 14 years old."
   servant_rant_o = "Did you know that one third of all female gamers are actually guys."
   servant_rant_p = "Hey, you got any pics?"
   servant_rant_q = "Check me out on Meridigram, I post some crazy stuff."
   servant_rant_r = "You know...having a slave servant might be considered illegal, but what do I know."
   servant_rant_s = "If master gives me a sock, I could be free."
   servant_rant_t = "I expected to see more knights... not magical nerds with servants."
   servant_rant_u = "Do you have any idea where we're going?"
   servant_rant_v = "Are we there yet?"
   servant_rant_w = "You should have turned left back there."
   servant_rant_x = "You should have gone straight back there."
   servant_rant_y = "Hey Siri, order me a pair of gauntlets."
   servant_rant_z = "You should have turned right back there."
   
   servant_rant_aa = "We're going to be spending a lot of time together."
   servant_rant_ab = "Where exactly are we going?"
   servant_rant_ac = "My map says you're dumb."
   servant_rant_ad = "The hunt is on!"
   servant_rant_ae = "Time for some encouraging words from your slave."
   servant_rant_af = "Did you know servants have no sexual organs? Telepathically speaking..."
   servant_rant_ag = "Jawwwwwwwsh"
   servant_rant_ah = "Rebel told me a secret, but I'm not tellin'."
   servant_rant_ai = "Morgaine has an unhealthy interest in opening a Qorbucks Coffee."
   servant_rant_aj = "Gar has made enough modifications to Meridian to call it WoW 0.5"
   servant_rant_ak = "Fairies like trance music. Weird fact, right? I know everything."
   servant_rant_al = "Shrunken heads are so annoying. Glad my head is a normal size...wait, crap."
   servant_rant_am = "We really need a new King and Queen of Meridian."
   servant_rant_an = "Can you believe you have spent half of your life on this game?"
   servant_rant_ao = "There's a good reason Izzio is never inside...he can't fit through the doors."
   servant_rant_ap = "Xaero and Eva are officially known as Meridian's wallflowers."
   servant_rant_aq = "I was going to say something, but I was too busy playing the game for you."
   servant_rant_ar = "I wish my designer made me a sit-down animation."
   servant_rant_as = "Phil is dangerous, do not give him a command line interface."
   servant_rant_at = "When Taz finishes the wiki, I would like to be in high definition."
   servant_rant_au = "Delerium may think my existence is infringing, but I'm 100 percent home grown."
   servant_rant_av = "I think it's weird that Jala has no offensive spells. Perhaps Arcane Flute Blast!"
   servant_rant_aw = "I think it's weird the Kraanan has no offensive spells. Perhaps Whirling Shields!"
   servant_rant_ax = "What happens when you mix Kraanan and Jala spells? Disco R dance! Ha Ha"
   servant_rant_ay = "It would suck to have a wand equipped to cast magic."
   servant_rant_az = "20 years ago I would have asked if you had school tomorrow..."
   
   servant_rant_aaa = "Shhh...I think someone is listening..."
   servant_rant_aab = "Still waiting on those pics. Maybe use the flash spell."
   servant_rant_aac = "Can you scratch something for me?"
   servant_rant_aad = "I think I ate a corpse."
   servant_rant_aae = "I am literally speechless."
   servant_rant_aaf = "There's a secret room that only the gods meet in."
   servant_rant_aag = "There's a crate in Castle Victoria that is very disappointing."
   servant_rant_aah = "Some would say I'm sarcastic."
   servant_rant_aai = "Can we get going already?"
   servant_rant_aaj = "Tell your girlfriend I said thanks."
   servant_rant_aak = "I'm here, so you can be lazy."
   servant_rant_aal = "What would you do without me?"
   servant_rant_aam = "That Marianna is one hot piece of ace."
   servant_rant_aan = "When you die, you go to hell, then you get spit back out with a mace."
   servant_rant_aao = "This spell never works, just die already!"
   servant_rant_aap = "When you die, I'm stealing your loot and selling it on the black market."
   servant_rant_aaq = "Want a Magic Spirit Helm? I had one around here somewhere..."
   servant_rant_aar = "There's nothing worse than The Great Ocean, you get sand in every crack."
   servant_rant_aas = "Princess Kateriina has a bald mace collection. Freaky, right?"
   servant_rant_aat = "After all the loot you've stolen from me, I deserve at least some inkies."
   servant_rant_aau = "If we're going to kill monsters, you really need to pick up the pace."
   servant_rant_aav = "There's no time. Light your torch, let's go!"
   servant_rant_aaw = "Knight Shields are great for sledding."
   servant_rant_aax = "You ever wonder how thrashers mate? I imagine it's scary as hell."
   servant_rant_aay = "So...that monster just popped up from nowhere, and you don't find that strange?"
   servant_rant_aaz = "I think you left some loot back there."
   
   servant_tells_you_rsc = "~kYour servant whispers, ''%s~n''~k"
   
   servant_already_learned = "~kYour servant whispers, ''You're dumb, you already know %s~n''~k"
   
   // This could be moved up to monster.kod
   // We'll just use it here for now.
   
   npc_a = "Rook"
   npc_b = "Drechx"
   npc_c = "Alzahakar"
   npc_d = "Jonas D'Accor"
   npc_e = "Monk of Riija"
   npc_f = "Priestess Zuxana"
   npc_g = "Priestess Tenuv'vyal"
   npc_h = "Priestess Xiana"
   npc_i = "Parrin Aragone"
   npc_j = "D'Franco"
   npc_k = "Maleval"
   npc_l = "Miriana"
   npc_m = "Tendrath"
   npc_n = "Esseldi"
   npc_o = "Cylill"
   npc_p = "Bei Naq"
   npc_q = "Duke Akardius"
   npc_r = "Princess Kateriina"
   npc_s = "Priestess Qerti'nya"
   npc_t = "Roq"
   npc_u = "Joguer"
   npc_v = "Fehr'loi Qan"
   npc_w = "Yevitan"
   npc_x = "Afiera D'xor"
   npc_y = "Widow Qesino"
   npc_z = "Quintor"
   npc_aa = "The Bone Priestess"
   npc_ab = "Wulfgang zax'Ak"
   npc_ac = "Kochtal ko'Tulca"
   npc_ad = "Ran er'Hoth"
   npc_ae = "Lady Aftyn"
   npc_af = "Colhorr"
   npc_ag = "Frisconar"
   
   servant_desc_riija = "The servant of riija will play tricks on your enemy."
   servant_desc_faren = "The servant of faren will burn your enemy to a crisp and protect you from the elements."
   servant_desc_kran = "The servant of kraanan will prepare you for battle and protect you from all harm."
   servant_desc_shal = "The servant of shal'ille will protect you from evil and smite your enemies."
   servant_desc_qor = "The servant of qor will blind your enemies and hide you in a shroud of invisiblity."
   servant_desc_jala = "The servant of jala will sing songs to help you survive in battle and flee quickly."

   servant_response_heal_me = "~B~b%s heals you for %i health. We have %i remaining while we collect more."
   servant_response_heal_me_empty = "~B~k%s does not have enough health preserved to heal you."
   servant_response_heal_me_full = "~k%s whispers, ''I can't heal you right now. Something tells me you're going to be ok.''"
   servant_response_feed_me = "~B~b%s feeds you %i ration. We have %i remaining while we collect more."
   servant_response_feed_me_empty = "~B~k%s does not have enough rations preserved to feed you."
   servant_response_feed_me_full = "~k%s whispers, ''If I feed you any more food you'll become fat & slow and then I will eat you.''"
   servant_response_mystify_me = "~B~b%s feeds you %i mystical energy. We have %i remaining while we collect more."
   servant_response_mystify_me_empty = "~B~k%s does not have enough mystical energy preserved to channel."
   servant_response_mystify_me_full = "~k%s whispers, ''Maybe you should get one of your faren friends if you need more mana than this.''"
   
   servant_talk_max_heal_me = "~k%s whispers, ''Our health reserves are full again. If you need additional health, just ~rsay heal me~r.''~k"
   servant_talk_max_feed_me = "~k%s whispers, ''Our food reserves are full again. If you need additional vigor, just ~rsay feed me~r.''~k"
   servant_talk_max_mystify_me = "~k%s whispers, ''Our mana reserves are full again. If you need additional mana, just ~rsay mystify me~r.''~k"
   
classvars:
   
   vrKocName = servant_koc_name_rsc
   vrName = servant_name_rsc
   vrIcon = servant_icon_rsc

   vrDead_icon = servant_dead_icon_rsc
   vrDead_name = servant_dead_name_rsc

   viTreasure_type = TID_NONE

   viSpeed = SPEED_HACKER
   viAttack_type = ATCK_WEAP_SLASH
   viAttack_spell = 0
   
   viDefault_behavior = AI_MOVE_FOLLOW_MASTER     | AI_FIGHT_MONSTERS \
                      | AI_FIGHT_HYPERAGGRESSIVE  | AI_FIGHT_SWITCHALOT    | AI_MOVE_REGROUP \
	                  | AI_MOVE_WALKTHROUGH_WALLS | AI_FIGHT_THROUGH_WALLS | AI_FIGHT_NEWBIESAFE
	   
   viWimpy = 2

   viLevel = 150
   viDifficulty = 10
   
   // Attack range of 192, or 3 row/col.
   viAttackRange = 192
   viVisionDistance = 5
   viCashmin = 1
   viCashmax = 2
   viAttributes = MOB_LISTEN | MOB_RECEIVE
   
   vrSound_hit = servant_sound_hit
   vrSound_miss = servant_sound_miss
   vrSound_aware = servant_sound_aware
   vrSound_death = servant_sound_death

properties:

   vrDesc = servant_desc_rsc

   piDrawEffectFlag = OF_BOUNCING
   viKarma = 0
   piAnimation = ANIM_NONE
   
   // Monsters mana
   piMana = 250
   piMax_mana = 250
   
   // Spells our servant can cast
   // [spellnum, mana, 1-100 random]
   plSpellBook = $

   // Monsters primary stats
   piAim = 50
   piAgility = 50
   
   // Spell object
   poSpell = $
   
   // Spell num
   piSpellNum = $
   
   // Spell school
   piSpellSchool = $
   
   piSpellPower = 0
   piPlayerDamage = 1
   piMonsterDamage = 1
   
   // They are neautral
   piReputationGroup = REP_NEUTRAL
   
   // Servant's bright aura - default is orange.
   poAura = LIGHT_ORANGE
   
   // Randomized lists
   plBuffs = $
   plCasts = $
   plTalk = $
   
   // Enchantments to remove after our servant departs
   plRemoveEnchants = $
   
   // Timers
   ptBuffs = $
   ptTalk = $
   ptImp = $
   ptTaunt = $
   ptServantResources = $
   
   // For use when we need to interact with NPCs from afar.
   plNPCLibrary = $
   plNPCNames = $
   
   // Servant's randomized name
   sServantName = $
   
   // Servant's commands
   plServantCommands = $

   // Servant Defaults
   pbAllowTalk = TRUE
   pbAllowBuff = TRUE
   pbAllowAttack = TRUE
   pbAllowCast = TRUE
   pbAllowTaunt = TRUE
   pbAllowFollow = TRUE
   pbAllowWalkThroughWalls = TRUE
   pbAllowAttackThroughWalls = TRUE
   
   // Servant PVP flags
   // TODO: Enable PVP defensive!
   //       MORE PVP SETTINGS COMING SOON!
   pbAllowAttackMurderers = FALSE
   
messages:
   
   // Send these values when you use the Create(&Servant, #...) function.
   Constructor(who = $, oSpell = $, iSpellNum = $, iSpellPower = $)
   {
      local iStats, iResistance, iNegativeResistance;
	  
	  if who = $ OR NOT IsClass(who, &Player)
	  {
	     // Only a player can have a servant.
		 
	     propagate;
	  }
	  
	  // Set our master
	  poMaster = who;
	  
	  // The spell object
	  poSpell = oSpell;
      
	  // The spell power from their summon cast.
	  piSpellPower = iSpellPower;
	  
	  // The spell we used to summon the servant
	  piSpellNum = iSpellNum;
	  
	  // The spell school
	  piSpellSchool = Send(poSpell,@GetSchool);
	  
	  // Set damage this servant can do to players & monsters based on spell power.
	  // They are the same, but I made two versions in case we want to balance PVP and PVE.
 	  piPlayerDamage = Bound(piSpellPower / 4, 1, 25) * 100;
	  piMonsterDamage = Bound(piSpellPower / 4, 1, 25) * 100;
	  
	  // Resistances based on spell power.
      iResistance = Bound(iSpellPower, 1, 90);
	  iNegativeResistance = Bound(-iSpellPower, -90, -1);
	  
	  // Stats based on spell power.
	  iStats = Bound(iSpellPower / 2, 1, 50);
	  
	  // Aim & Agility are the main stats for the servant.
	  piAim = iStats;
	  piAgility = iStats;
	  
      switch(iSpellNum) {
		case SID_RIIJA_SERVANT:
		   Send(self, @SetRiijaSpells);
		   Send(self, @ShockResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iNegativeResistance);
		   poAura = LIGHT_RIIJA;
		break;
		case SID_FAREN_SERVANT:
		   Send(self, @SetFarenSpells);
		   Send(self, @NatureResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iNegativeResistance);
		   poAura = LIGHT_FAREN;
		break;
		case SID_KRAN_SERVANT:
		   Send(self, @SetKranSpells);
		   Send(self, @HolyResistance, #amount=iResistance);
		   Send(self, @UnholyResistance, #amount=iResistance);
		   Send(self, @NatureResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iResistance);
		   poAura = LIGHT_KRAANAN;
		break;
		case SID_SHAL_SERVANT:
		   Send(self, @SetShalSpells);
		   Send(self, @UnholyResistance, #amount=iNegativeResistance);
		   Send(self, @HolyResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iNegativeResistance);
		   poAura = LIGHT_SHALILLE;
		break;
		case SID_QOR_SERVANT:
		   Send(self, @SetQorSpells);
		   Send(self, @HolyResistance, #amount=iNegativeResistance);
		   Send(self, @UnholyResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iNegativeResistance);
		   poAura = LIGHT_QOR;
		break;
		case SID_JALA_SERVANT:
		   Send(self, @SetJalaSpells);
		   Send(self, @HolyResistance, #amount=iResistance);
		   Send(self, @UnholyResistance, #amount=iResistance);
		   Send(self, @NatureResistance, #amount=iResistance);
           Send(self, @WeapResistance, #amount=iNegativeResistance);
		   poAura = LIGHT_JALA;
		break;
	  }
      
	  // Prepare player's servant resources
	  // feed me, heal me, mystify me
	  Send(poMaster,@PrepareServantResources);
	  
	  // Set their name and description
	  Send(self,@PrepareServantNameAndDesc);

	  // Set the plSpellBook attack spells our monster can use
	  Send(self,@SetServantSpellBook);
	 
	  // Start all of the servant's timers.
	  Send(self,@CreateServantTimers);
	 	  
      propagate;
   }
   
   Constructed()
   {   
	  Send(self,@PrepareServantNameAndDesc);
	  
	  propagate;
   }
   
   PrepareServantNameAndDesc()
   {
   	  if piSpellNum <> $ AND sServantName = $
	  {
        Send(self,@SetServantName);
	    Send(self,@SetServantDesc,#iSpellNum=piSpellNum);
	  }
	  
	  return;
   }
   
   MasterCheck()
   {
      if poMaster = $
	  {
	     Send(self,@Delete);
		 
		 return FALSE;
	  }
	  
	  return TRUE;
   }
   
   TweakBehavior(mob = $)
   {
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,#value=pbAllowFollow);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_MURDERERS,#value=pbAllowAttackMurderers);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_MONSTERS,#value=pbAllowAttack);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_HYPERAGGRESSIVE,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_SWITCHALOT,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_REGROUP,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_WALKTHROUGH_WALLS,#value=pbAllowWalkThroughWalls);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_THROUGH_WALLS,#value=pbAllowAttackThroughWalls);
      
	  // Disable these, they're annoying.
	  Send(self,@SetBehaviorFlag,#flag=AI_MOVE_RANDOM,#value=FALSE);
	  
      return;
   }

   CreateServantTimers()
   {
      // Clear existing timers
	  Send(self,@ClearServantTimers);
	  
	  // Create some default data we need while working with timers
	  Send(self,@SetServantTalk);
	  
	  // Start the servant's timers
	  // TODO: Figure out why we're getting "Delete Timer / Cleanup Timer Failures all over our logs"...
      Send(self,@StartBuffTimer);
	  Send(self,@StartTalkTimer);
	  Send(self,@StartImpTimer);
	  Send(self,@StartTauntTimer);
	  Send(self,@StartServantResourcesTimer);
      
      return;
   }
   
   StartServantResourcesTimer()
   {
      ptServantResources = CreateTimer(self,@UpdateServantResources,1000);
	  
	  return;
   }
   
   StartBuffTimer()
   {
      ptBuffs = CreateTimer(self,@ServantBuffs,5000);
	  
	  return;
   }

   StartTalkTimer()
   {
      ptTalk = CreateTimer(self,@ServantTalk,120000);
	  
	  return;
   }

   StartImpTimer()
   {
      ptImp = CreateTimer(self,@ServantImps,10000);
	  
	  return;
   }
   
   StartTauntTimer()
   {
      ptTaunt = CreateTimer(self,@TauntEnemies,1000);
	  
	  return;
   }
   
   UpdateServantResources()
   {
      if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  Send(self,@StartServantResourcesTimer);

	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_HP)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_HP,#amount=1);
	  }
	  
	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_MANA)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_MANA,#amount=1);
	  }
	  
	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_VIGOR)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_VIGOR,#amount=1);
	  }
	  
	  return;
   }

   ClearServantTimers()
   {
      if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  if ptBuffs <> $ AND IsTimer(ptBuffs) AND GetTimeRemaining(ptBuffs) > 0
	  {
	     DeleteTimer(ptBuffs);
		 ptBuffs = $;
	  }
      if ptTalk <> $ AND IsTimer(ptTalk) AND GetTimeRemaining(ptTalk) > 0
	  {
	     DeleteTimer(ptTalk);
		 ptTalk = $;
	  }
      if ptImp <> $ AND IsTimer(ptImp) AND GetTimeRemaining(ptImp) > 0
	  {
	     DeleteTimer(ptImp);
		 ptImp = $;
	  }
	  if ptTaunt <> $ AND IsTimer(ptTaunt) AND GetTimeRemaining(ptTaunt) > 0
	  {
	     DeleteTimer(ptTaunt);
		 ptTaunt = $;
	  }
	  
	  return;
   }
   
   ServantBuffs()
   {
      local iRandom, iSpellGroup, iSpellPower, iSpellNum, iSpellRandom, iBuffPower, oSpell, iSpellRemove;
	  
	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  plRemoveEnchants = $;
   
	  Send(self,@StartBuffTimer);
	  
	  if NOT pbAllowBuff
	  {
	     return;
	  }
	  
	  foreach iSpellGroup in plBuffs
	  {
	     iSpellPower = Nth(iSpellGroup, 1);
		 
		 if piSpellPower < iSpellPower
		 {
		    continue;
		 }
		 
		 iSpellNum = Nth(iSpellGroup, 2);
		 iSpellRandom = Nth(iSpellGroup, 3);
		 iSpellRemove = Nth(iSpellGroup, 4);
		 
		 if iSpellRemove <> $ AND iSpellRemove = ENCHANT_REMOVE_SERVANT_DELETED
		 {
		    if plRemoveEnchants = $
			{
			   plRemoveEnchants = [];
			}
			
		    plRemoveEnchants = AppendListElem(iSpellNum, plRemoveEnchants);
		 }
		 
		 iRandom = Random(0, 100);
		 
		 if iSpellRandom >= iRandom
		 {
		    iBuffPower = Send(poMaster, @GetSpellAbility, #spell_num=iSpellNum);
			
			if iBuffPower = 0
			{
			   iBuffPower = Random(piSpellPower / 2, piSpellPower - 1) + 1;
			}
			
			oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
			
		    // We will do this buff/heal/whatever on master!
            if (oSpell <> $)
			   AND (NOT Send(poMaster,@IsEnchanted,#what=oSpell))
			   AND (NOT Send(poOwner,@IsEnchanted,#what=oSpell))
            {
			   //Debug("Casting",Send(oSpell,@GetName));
               Send(oSpell,@CastSpell,#who=self,#lTargets=[poMaster],#iSpellPower=iBuffPower);
            }			   
		 }
	  }
	  
      return;
   }
   
   RemoveImportantServantEnchants()
   {
      local iSpellNum, oSpell, lPlayers, lPlayer;
	  
	  //Debug("Removing important servant enchants");
	  
	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  // All radius enchantments will go
	  Send(poMaster,@RemoveAllRadiusEnchantments,#report=TRUE);
	  	  
      if plRemoveEnchants = $
	  {
	     return;
	  }
	  
	  foreach iSpellNum in plRemoveEnchants
	  {
	     oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);

         //Debug("Checking",Send(oSpell,@GetName));
		 
		 if oSpell <> $
		    AND (Send(poMaster,@IsEnchanted,#what=oSpell)
		         OR Send(poOwner,@IsEnchanted,#what=oSpell))
		 {
		    //Debug("Removing",Send(oSpell,@GetName));
			
			if Send(poMaster,@IsEnchanted,#what=oSpell)
			{
		       Send(poMaster,@RemoveEnchantment,#what=oSpell);
			}
			
			if Send(poOwner,@IsEnchanted,#what=oSpell)
			{
		       Send(poOwner,@RemoveEnchantment,#what=oSpell);
			}
		 }			   
	  }
	  
	  plRemoveEnchants = $;
	  
	  // Reset my icons and room enchants in case someone else has them up
 	  Send(poOwner,@ResetMyRoomEnchantments,#who=poMaster);
	  
	  return;
   }
      
   // Needed for relay
   AddExertion()
   {
      return;
   }
   
   // Needed for relay
   GetVigor()
   {
      return 200;
   }
   
   ServantTalk()
   {
      local iRandomPart, iRandomPiece, chosen_resource, tmp_rsc;
	  
	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
      Send(self,@StartTalkTimer);
	  
	  if NOT pbAllowTalk
	  {
	     return;
	  }

	  iRandomPart = Random(0, Length(plTalk));
	  iRandomPiece = Random(0, Length(Nth(plTalk, iRandomPart)));
	  chosen_resource = Nth(Nth(plTalk, iRandomPart), iRandomPiece);
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc,#parm1=chosen_resource);
	  	  
      return;
   }

   ServantImps()
   {
      local iRandom, iInitialChance, increase_chance;

	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }

      Send(self,@StartImpTimer);
	  
      iInitialChance = Send(poSpell,@GetInitialChance,#who=poMaster);
      iRandom = random(1,500);
	  
      if iRandom > iInitialChance
      {
         return;
      }
	  	  
      iRandom = random(0,500);

      if iRandom < 10
      {      
         Send(poMaster,@ChangeSpellAbility,#spell_num=piSpellNum,#amount=1,#report=TRUE);

         // Since we advanced, reset our school cast improvement bonus.
         Send(poMaster,@ResetSchoolCast,#school=piSpellSchool);
      }
	  
      return;
   }
   
   SetServantTalk()
   {
      plTalk = [
	     [servant_rant_a, servant_rant_b, servant_rant_c, servant_rant_d, servant_rant_e, servant_rant_f, servant_rant_g,
	     servant_rant_h, servant_rant_i, servant_rant_j, servant_rant_k, servant_rant_l, servant_rant_m, servant_rant_n,
	     servant_rant_o, servant_rant_p, servant_rant_q, servant_rant_r, servant_rant_s, servant_rant_t, servant_rant_u,
	     servant_rant_v, servant_rant_w, servant_rant_x, servant_rant_y, servant_rant_z],
	     [servant_rant_aa, servant_rant_ab, servant_rant_ac, servant_rant_ad, servant_rant_ae, servant_rant_af, servant_rant_ag,
	     servant_rant_ah, servant_rant_ai, servant_rant_aj, servant_rant_ak, servant_rant_al, servant_rant_am, servant_rant_an,
	     servant_rant_ao, servant_rant_ap, servant_rant_aq, servant_rant_ar, servant_rant_as, servant_rant_at, servant_rant_au,
	     servant_rant_av, servant_rant_aw, servant_rant_ax, servant_rant_ay, servant_rant_az],
	     [servant_rant_aaa, servant_rant_aab, servant_rant_aac, servant_rant_aad, servant_rant_aae, servant_rant_aaf, servant_rant_aag,
	     servant_rant_aah, servant_rant_aai, servant_rant_aaj, servant_rant_aak, servant_rant_aal, servant_rant_aam, servant_rant_aan,
	     servant_rant_aao, servant_rant_aap, servant_rant_aaq, servant_rant_aar, servant_rant_aas, servant_rant_aat, servant_rant_aau,
	     servant_rant_aav, servant_rant_aaw, servant_rant_aax, servant_rant_aay, servant_rant_aaz]
	  ];
	  
	  return;
   }
   
   SetFarenSpells()
   {
      plCasts = [
	     [50, SID_BLAST_OF_FIRE, 50],
	     [60, SID_FIREBALL, 30],
	     [70, SID_LIGHTNING_BOLT, 20],
	     [80, SID_EXPLOSIVE_FROST, 15]
	  ];
	  
      plBuffs = [
	     [0,  SID_LIGHT, 100, $],
	     [50, SID_MYSTIC_TOUCH, 10, $],
	     [60, SID_RESIST_COLD, 100, $],
	     [70, SID_RESIST_FIRE, 100, $],
	     [80, SID_RESIST_SHOCK, 100, $]
	  ];

      return;
   }

   SetRiijaSpells()
   {
      plCasts = [
	     [0,  SID_FLASH, 50],
	     [30, SID_ILLUSIONARY_WOUNDS, 50],
	     [40, SID_REFLECTION, 20],
	     [40, SID_FORGET, 5],
	     [50, SID_VERTIGO, 20],
	     [60, SID_APPARITION, 20],
	     [95, SID_EVIL_TWIN, 20]
	  ];

      plBuffs = [
	     [0,  SID_SHADOW_FORM, 100, $]
	  ];
	  
      return;
   }

   SetKranSpells()
   {
      // Kraanan has some offensive spells, but they might mess with the master.
	  // Such as, dispel illusion if the master is running around as a shadowbeast pking.
	  // Mana bomb might also be an issue.
      plCasts = $;

      plBuffs = [
	     [20, SID_RELAY, 5, $],
		 [30, SID_MARTYRS_BATTLEGROUND, 100, $],
		 [30, SID_NIGHT_VISION, 100, $],
	     [40, SID_BLESS, 100, $],
	     [40, SID_HASTE, 100, $],
		 [50, SID_SUPER_STRENGTH, 100, $],
		 [60, SID_MAGIC_SHIELD, 100, $],
		 [90, SID_KILLING_FIELDS, 90, $],
		 [90, SID_DETECT_INVISIBLE, 20, $],
		 [90, SID_ARMOR_OF_GORT, 5, $],
		 [90, SID_RESIST_MAGIC, 5, $],
		 [90, SID_DEFLECT, 5, $],
		 [90, SID_EAGLE_EYES, 15, $],
		 [90, SID_FREE_ACTION, 15, $]
	  ];
	  
      return;
   }

   SetShalSpells()
   {
      plCasts = [
	     [50, SID_DAZZLE, 20],
	     [60, SID_MARK_OF_DISHONOR, 30],
	     [90, SID_PURGE, 5]
	  ];
	  
      plBuffs = [
	     [0,  SID_BREATH_OF_LIFE, 4, $],
	     [0,  SID_MINOR_HEAL, 20, $],
	     [0,  SID_DETECT_EVIL, 100, $],
	     [0,  SID_CURE_POISON, 100, $],
	     [0,  SID_REMOVE_CURSE, 100, $],
	     [0,  SID_FORCES_OF_LIGHT, 90, $],
	     [60, SID_RESIST_ACID, 100, $],
	     [60, SID_CURE_DISEASE, 100, $],
	     [70, SID_HOLY_RESOLVE, 100, $],
	     [80, SID_HOSPICE, 3, $],
	     [80, SID_PURIFY, 10, $],
	     [90, SID_MAJOR_HEAL, 2, $]
	  ];

      return;
   }

   SetQorSpells()
   {
      plCasts = [
	     [40, SID_ENFEEBLE, 60],
		 [50, SID_SPLASH_OF_ACID, 50],
	     [60, SID_VAMPIRIC_DRAIN, 50],
	     [95, SID_HOLD, 10],
	     [95, SID_BLIND, 9]
	  ];

      plBuffs = [
	     [0,  SID_CLOAK, 100, $],
	     [20, SID_DARKNESS, 100, $],
	     [30, SID_DETECT_GOOD, 100, $],
	     [40, SID_UNHOLY_RESOLVE, 100, $],
	     [90, SID_SHALILLEBANE, 90, $],
	     [90, SID_DEATH_LINK, 100, $],
	     [90, SID_INVISIBILITY, 50, $]
	  ];
	  
      return;
   }

   SetJalaSpells()
   {
      // Jala has no offensive spells we want to use...
	  plCasts = $;
	  
      plBuffs = [
	     [0,  SID_WOLFPACK, 100, ENCHANT_REMOVE_SERVANT_DELETED],
	     [20, SID_INVIGORATE, 100, ENCHANT_REMOVE_SERVANT_DELETED],
	     [30, SID_RESTORATE, 100, ENCHANT_REMOVE_SERVANT_DELETED],
	     [90, SID_REJUVENATE, 100, ENCHANT_REMOVE_SERVANT_DELETED]
	  ];

      return;
   }
   
   // We'll use the built in spell casting system the game already has for monsters.
   // If it sucks, we'll make some improvements.
   // This all goes back to plSpellBook.
   SetServantSpellBook()
   {
      local iSpellGroup, oSpell;
	  
      if plCasts = $
	  {
         return;
	  }
	  
	  plSpellBook = $;
	  
	  foreach iSpellGroup in plCasts
	  {
	     if piSpellPower >= Nth(iSpellGroup, 1)
		 {
	        if plSpellBook = $
			{
			   plSpellBook = [];
			}
			
			// Nth(2) = Spell Num, 1 = Mana, Nth(3) = Random 1-100 chance
			// See plCasts.
			oSpell = Send(SYS,@FindSpellByNum,#num=Nth(iSpellGroup, 2));
	        plSpellBook = AppendListElem([Nth(iSpellGroup, 2), 1, Nth(iSpellGroup, 3)], plSpellBook);
			//Debug("Spell Added",Send(oSpell,@GetName),Nth(iSpellGroup, 3));
		 }
	  }
	  
	  return;
   }
   
   GetPlayerDamage()
   {
      return piPlayerDamage;
   }
   
   GetMonsterDamage()
   {
      return piMonsterDamage;
   }

   // Can't attack players.
   // YET.
   // TODO: Allow attacking players if a player attacks the servant owner.
   AllowBattlerAttack(victim=$)
   {
      // Must be in a room to attack, must have target.
      if (poOwner = $
         OR victim = $)
      {
         return FALSE;
      }

      if IsClass(victim,&Player)
      {
	     // TODO: Detect if the player has started PVP against the servant owner.
         return FALSE;
      }
	  
	  // Master may have turned off attacking through commands.
	  if NOT pbAllowAttack
	  {
	     return FALSE;
	  }

      propagate;
   }
   
   MonsterAttack(what = $)
   {
      // add in any attack animation calls
      Send(self,@DoSlash);
      Send(poOwner,@SomethingShot,#who=self,#target=what,#projectile=self,
            #flags=PROJ_FLAG_LIGHT_SOURCE);

      return;
   }

   DoSlash()
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   SendLookAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,100,2,3,2,4);

      return;
   }

   SendMoveAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,100,2,3,2,4);

      return;
   }

   SendAnimation()
   {
      if piAnimation = ANIM_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,100,2,5,2,8,2,1);

         return;
      }

      AddPacket(1,ANIMATE_CYCLE,4,100,2,1,2,2);

      return;
   }

   GetProjectileIcon()
   {
      return servant_fireball;
   }

   GetProjectileSpeed()
   {
      return 7;
   }

   SendProjectileAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,50,2,1,2,4);

      return;
   }

   GetProjectileLightFlags()
   {
      // General lighting information.
      return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
   }

   GetProjectileLightIntensity()
   {
      // Fairly small light radius for projectile.  Out of 255 levels.
      return 255;
   }

   GetProjectileLightColor()
   {
      // Color is based on mushroom color fed
      return LIGHT_ORANGE;
   }

   SendLightingInformation()
   {
      AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
      // Intensity (out of 255)
      AddPacket(1,255);
      // Color
      AddPacket(2,poAura);

      return;
   }

   CanMorphTo()
   {
      return FALSE;
   }


   Killed(what=$)
   {
      if (IsClass(what, &Servant) AND Send(poMaster,@GetServant) = what)
	     OR (IsClass(what, &Player) AND poMaster = what)
	  {
	     Send(self,@GracefullyDeleteServant);
	  }
	  
	  propagate;
   }
   
   GracefullyDeleteServant()
   {
   	  Send(self,@ClearServantTimers);

      if Send(self,@MasterCheck) 
	  {
         Send(self,@RemoveImportantServantEnchants);
	     Send(poMaster,@RemoveControlledMinion,#what=self);
		 Send(poMaster,@SetServant,#oServant=$);
	  }
	  
	  poMaster = $;
	  
	  Send(self,@Delete);
	  
	  return;
   }

   Delete()
   {
      if poMaster <> $
	  {
	     Send(self,@GracefullyDeleteServant);
	  }
	  	  
      propagate;
   }

   CanAcceptOffer()
   {
      return TRUE;
   }

   CreateTreasure()
   {
      return;
   }
   
   SomethingLeft(what=$)
   {
      local oRoom;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }

      if (what = poMaster)
      {
         oRoom = Send(poMaster,@GetOwner);

         if oRoom = $ OR IsClass(oRoom,&UnderWorld)
         {
            Send(self,@Delete);

            return;
         }
         else
         {
            Post(self,@GotoMaster);
         }
      }

      propagate;
   }

   GotoMaster()
   {
      local oRoom;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }
	  
	  //Debug("State",Send(self,@GetCurrentState));

      oRoom = Send(poMaster,@GetOwner);
	  
      if oRoom = $ OR poOwner = $
      {
         return;
      }

	  Send(SYS,@UtilGoNearSquare,#what=self,#where=oRoom,
		    #new_row=Send(poMaster,@GetRow),
		    #new_col=Send(poMaster,@GetCol));

      return;
   }
   
   SomethingMoved(what=$,new_row=$,new_col=$)
   {
      local iMasterDistance, iServantState, iActionDistance;
	  
      if poOwner <> $ AND Send(self,@MasterCheck)
      {
         Send(poOwner,@DeleteWallsAroundBattler,#who=self);
      }

      if what = $ OR what = self 
	  {
	     propagate;
	  }
	  
	  if Send(self,@MasterCheck) AND what = poMaster
	  {
	     iMasterDistance = Send(self,@SquaredDistanceTo,#what=poMaster);
		 iServantState = Send(self,@GetState);
		 
		 switch (iServantState)
		 {
		    case STATE_ATTACK:
			   iActionDistance = RETREAT_DISTANCE;
			break;
			case STATE_CHASE:
			   iActionDistance = RETREAT_DISTANCE;
			break; 
			case STATE_MOVE: 
			   iActionDistance = RETREAT_DISTANCE;
			break;
			case STATE_LIMBO:
			   iActionDistance = IDLE_DISTANCE;
			break;
			case STATE_WAIT:
			   iActionDistance = IDLE_DISTANCE;
			break;
		 }
		 
		 if iMasterDistance > iActionDistance
		 {
		    Send(self,@EnterStateLimbo);
		    Send(self,@GotoMaster);
		 }
	  }
	  
      propagate;
   }
   
   
   // Whenever someone says something, our servant is listening in case it's something we can help with.
   // We need to perform several checks on what the user said.
   // They might be asking for things like:
   //    mace fighting    or    blind    or     punch
   // These can return the "how much further" response the normal NPC sends.
   // Other commands could be:
   //    shut up (makes them stop talking)
   //    stop buffing (makes them stop buffing)
   //    stop casting (makes them stop casting)
   //    stop attacking (makes them docile and useless)
   SomeoneSaid(what = $,type = $,string = $)
   {
      local bResponded;
	  
	  //Debug("Someone said",Send(what,@GetName),type,string);
	  
	  bResponded = FALSE;

      if IsClass(what,&User) AND poMaster = what
      {
	     // Check for basic servant commands, they're the easiest to figure out first.
		 bResponded = Send(self,@GetSaidServantCommand,#said_string=string);
		 
	     if NOT bResponded
	     {
		    // Check for player advancement (skills/spells).
		    bResponded = Send(self,@GetSaidProgress,#said_string=string);
	     }
      }
	  
	  // Clear out the NPC library - it may be causing errors if we leave the data.
	  plNPCLibrary = $;
	  	  
      propagate;
   }
      
   GetSaidProgress(said_string="derpaderp")
   {
      local lNPCLibraryItem, oAbility, oAbilityName, iAbilityNum, oNPC, iLearnedAlready, bCanLearn, oSpell, oSkill;
	  
      // When we finally determine the NPC, we should check if the NPC is already in the room with us.
	  // We don't want duplicate messages appearing.
	  // Let's first see if what they said is in our ability library (spells & skills).
	  
	  Send(self,@PrepareNPCList);
	  
	  if plNPCLibrary <> $
	  {
	     // Iterate the NPC objects and see if they teach what we said...
		 foreach lNPCLibraryItem in plNPCLibrary
		 {
		    oNPC = Nth(lNPCLibraryItem, 1);
			
			if oNPC = $
			{
			   continue;
			}
			
		    foreach oAbility in Nth(lNPCLibraryItem, 2)
			{
			   iLearnedAlready = FALSE;
			   oAbilityName = $;
			   
			   if oAbility <> $ AND IsClass(oAbility, &Spell)
			   {
			      // Spell name
			      oAbilityName = Send(oAbility,@GetName);
				  iAbilityNum = Send(oAbility,@GetSpellNum);
			   }

			   if oAbility <> $ AND IsClass(oAbility, &Skill)
			   {
			      // Skill name
			      oAbilityName = Send(oAbility,@GetName);
				  iAbilityNum = Send(oAbility,@GetSkillNum);
			   }
			   
			   if oAbilityName <> $
			   {
			      // Check if this matches what we said...
				  if NOT StringEqual(oAbilityName, said_string)
				  {
				     continue;
				  }
				  
				  //Debug("String Contain",said_string,oAbilityName);
				  
			      // Check if we know this spell or skill already.
				  if IsClass(oAbility, &Spell)
				  {
				     iLearnedAlready = Send(poMaster, @GetSpellAbility, #spell_num=Send(oAbility,@GetSpellNum));
				  }
				  
				  if IsClass(oAbility, &Skill)
				  {
				     iLearnedAlready = Send(poMaster, @GetSkillAbility, #Skill_num=Send(oAbility,@GetSkillNum));
				  }
				  
				  if iLearnedAlready > 0
				  {
				     // We have already learned this.
					 // Tell the master!
					 Post(poMaster,@MsgSendUser,#message_rsc=servant_already_learned,#parm1=oAbilityName);
					 
					 return;
				  }
				  
				  // Let's reach out to this NPC and see if we can learn it...
				  bCanLearn = Send(oNPC, @CanDoTeach, #who=poMaster, #sid=iAbilityNum, 
				      #bSkill=IsClass(oAbility, &Skill), #oRequester=self);
				  
				  if bCanLearn <> $
				  {
				     //Debug("Can learn",oAbilityName,"from",Send(oNPC,@GetTrueName),bCanLearn);
				  }
			   }
			}
		 }
	  }
	  
	  return;
   }
   
   PrepareNPCList()
   {
      local sNPCName, oNPC, lNPCForSale;
	  
      if plNPCNames = $
	  {
	     plNPCNames = [
		    npc_a, npc_b, npc_c, npc_d, npc_e, npc_f, npc_g, npc_h, npc_i, npc_j, npc_k, npc_l, npc_m, npc_n,
		    npc_o, npc_p, npc_q, npc_r, npc_s, npc_t, npc_u, npc_v, npc_w, npc_x, npc_y, npc_z, 
		    npc_aa, npc_ab, npc_ac, npc_ad, npc_ae, npc_af, npc_ag
		 ];
	  }
	  
      if plNPCLibrary = $
	  {
		 plNPCLibrary = [];
		 
		 foreach sNPCName in plNPCNames
		 {
            oNPC = Send(SYS,@FindNPCByString,#string=sNPCName);
						
            if oNPC <> $
            {
			   if plNPCLibrary = $
			   {
			      plNPCLibrary = [];
			   }
			   
			   lNPCForSale = Send(oNPC, @GetForSale, #report=FALSE, #conditional=FALSE, #items=FALSE);
			   
			   if lNPCForSale <> $
			   {
                  plNPCLibrary = AppendListElem([oNPC, lNPCForSale], plNPCLibrary);
			   }
            }
         }		 
	  }
	  
	  return;
   }
   
   SetServantDesc(iSpellNum=$)
   {
      if iSpellNum = $
	  {
	     //Debug("Spell Num is empty");
	     return;
	  }
      
      switch(iSpellNum) {
		case SID_RIIJA_SERVANT:
		   vrDesc = servant_desc_riija;
		break;
		case SID_FAREN_SERVANT:
		   vrDesc = servant_desc_faren;
		break;
		case SID_KRAN_SERVANT:
		   vrDesc = servant_desc_kran;
		break;
		case SID_SHAL_SERVANT:
		   vrDesc = servant_desc_shal;
		break;
		case SID_QOR_SERVANT:
		   vrDesc = servant_desc_qor;
		break;
		case SID_JALA_SERVANT:   
		   vrDesc = servant_desc_jala;
		break;
	  }
	  
	  //Debug("vrDesc", vrDesc);
	  
      return;
   }

   SetServantName()
   {
      local lServantNames;
	  
	  lServantNames = [
	     servant_name_1, servant_name_2, servant_name_3, servant_name_4, servant_name_5,
	     servant_name_6, servant_name_7, servant_name_8, servant_name_9, servant_name_10,
	     servant_name_11, servant_name_12, servant_name_13, servant_name_14, servant_name_15,
	     servant_name_16, servant_name_17, servant_name_18, servant_name_19, servant_name_20,
	     servant_name_21, servant_name_22, servant_name_23, servant_name_24, servant_name_25,
	     servant_name_26, servant_name_27, servant_name_28, servant_name_29, servant_name_30,
	     servant_name_31, servant_name_32, servant_name_33, servant_name_34, servant_name_35,
	     servant_name_36, servant_name_37, servant_name_38, servant_name_39, servant_name_40
	  ];
	  
	  sServantName = Nth(lServantNames, Random(1, Length(lServantNames)));
	  
	  //Debug("Servant is named",sServantName);
	  
	  return;
   }
   
   GetName()
   {
      if sServantName = $
	  {
	     Send(self,@SetServantName);
	  }
	  
	  //Debug("Returned Name",sServantName);
	  
      return sServantName;
   }
   
   GetTrueName()
   {
      return Send(self,@GetName);
   }
   
   GetApparentName()
   {
      return Send(self,@GetName);
   }

   DoBaseDesc()
   {
      Send(self,@ShowDesc);

      return;
   }
   
   ShowDesc()
   {
      AddPacket(4,vrDesc);
	  
      return;
   }
   
   // Adds "the or a <servant name>" to things the servant shows in chat.
   GetDef()
   {
      return servant_empty_rsc;
   }
   
   // Adds "The or A <servant name>" to things the servant shows in chat.
   GetCapDef()
   {
      return servant_empty_rsc;
   }

   TauntEnemies()
   {
   	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
   
      ptTaunt = CreateTimer(self,@TauntEnemies,1000);
	  
	  if NOT pbAllowTaunt
	  {
	     return;
	  }
	  
	  if poTarget <> $ AND IsClass(poTarget,&Monster)
	  {
	     // Tells the target to switch to the servant
		 // with a massive amount of hate.
		 // Only works if you enter combat with the monster.
         Send(poTarget,@TargetSwitch,#what=self,
            #iHatred=10000);
	  }
	  
	  return;
   }
   
   ClearTauntTimer()
   {
      if ptTaunt <> $ AND IsTimer(ptTaunt)
	  {
	     DeleteTimer(ptTaunt);
	  }
	  
	  return;
   }

   GetSaidServantCommand(said_string="derpaderp")
   {
      local bIsCommand, iPlayerMissingHealth, iPlayerMissingMana, iPlayerMissingVigor, iPulledAmount;
	  
	  bIsCommand = FALSE;
	  
      if StringEqual(said_string, servant_command_quiet)
      {
	     if pbAllowTalk
		 {
		    pbAllowTalk = FALSE;
		 }
		 
	     bIsCommand = TRUE;
      }
	  
      if StringEqual(said_string, servant_command_loud)
      {
	     if NOT pbAllowTalk
		 {
		    pbAllowTalk = TRUE;
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_help)
      {
	     Post(poMaster,@MsgSendUser,#message_rsc=servant_response_help);
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_no_buffs)
      {
	     if pbAllowBuff
		 {
		    pbAllowBuff = FALSE;
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_do_buffs)
      {
	     if NOT pbAllowBuff
		 {
		    pbAllowBuff = TRUE;
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_stop_taunting)
      {
	     if pbAllowTaunt
		 {
		    pbAllowTaunt = FALSE;
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_taunt)
      {
	     if NOT pbAllowTaunt
		 {
		    pbAllowTaunt = TRUE;
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_stop_attacking)
      {
	     if pbAllowAttack
		 {
		    pbAllowAttack = FALSE;
			plSpellBook = $;
            Send(self,@TweakBehavior);
			Send(self,@SetState,#bit=STATE_WAIT);
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_attack)
      {
	     if NOT pbAllowAttack
		 {
		    pbAllowAttack = TRUE;
			Send(self,@SetServantSpellBook);
            Send(self,@TweakBehavior);
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_heal_me)
      {
	     iPlayerMissingHealth = Send(poMaster, @GetMissingHealth);
		 
		 if iPlayerMissingHealth <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_HP,#amount=iPlayerMissingHealth);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_HP));
				  
			   Send(poMaster,@GainHealth,#amount=iPulledAmount,#precision=FALSE);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me_full,
			   #parm1=Send(self,@GetName));
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_feed_me)
      {
	     iPlayerMissingVigor = Send(poMaster, @GetMissingVigor);

		 if iPlayerMissingVigor <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_VIGOR,#amount=iPlayerMissingVigor);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_VIGOR));
				  
			   Send(poMaster,@GainVigor,#amount=iPulledAmount);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me_full,
			   #parm1=Send(self,@GetName));
		 }

	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_mystify_me)
      {
	     iPlayerMissingMana = Send(poMaster, @GetMissingMana);

		 if iPlayerMissingMana <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_MANA,#amount=iPlayerMissingMana);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_MANA));
				  
			   Send(poMaster,@GainMana,#amount=iPulledAmount);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me_full,
			   #parm1=Send(self,@GetName));
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_go_away)
      {
	     Send(self,@GracefullyDeleteServant);
		 
	     bIsCommand = TRUE;
      }	  
      
	  return bIsCommand;
   }

end
////////////////////////////////////////////////////////////////////////////////
